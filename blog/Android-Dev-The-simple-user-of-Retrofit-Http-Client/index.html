<!DOCTYPE html><html lang="default"><head><meta charset="UTF-8"><meta name="author" content="Zijian Wang"><meta name="desciption" content="暂无描述，哈"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Andriod集成Retrofit网络请求库指南</title><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/carbon.css"><script defer="defer" src="//cdn.jsdelivr.net/jquery/2.1.4/jquery.min.js"></script><script defer="defer" src="//cdn.jsdelivr.net/jquery.pjax/1.9.5/jquery.pjax.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.css" type="text/css" media="screen"><script defer="defer" type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>var performFancybox = true;</script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/katex/0.5.0/katex.min.css"><script async="async" type="text/javascript" src="//cdn.jsdelivr.net/katex/0.5.0/katex.min.js"></script><script async="async" type="text/javascript" src="//cdn.jsdelivr.net/katex/0.5.0/contrib/auto-render.min.js"></script><script>var doRenderMath = 'katex';</script><script defer="defer" src="/js/carbon.js"></script></head><body><div id="container"><div id="banner"><h1 id="site-title"><a href="/">Cody.W的哈哈BLOG</a></h1><p id="site-subtitle">欢迎大家来讨论</p></div><div id="content"><div class="meta"><h2 class="article-title"><a href="/blog/Android-Dev-The-simple-user-of-Retrofit-Http-Client">Andriod集成Retrofit网络请求库指南</a></h2><div class="article-date"><a href="javascript:void(0);" class="extra-switch">2015-05-22</a></div></div><div class="extra"><span class="Tags">Tags: <a href="/tags/Android/">Android</a>, <a href="/tags/Retrofit/">Retrofit</a>.</span></div><div class="extra"><span class="Categories">Categories: None.</span></div><div class="article-content"><div class="gallery"></div><p>近期我在我们的项目中大量的集成了Retrofit网络请求框架，经过了对Retrofit几天的了解，感觉这个库确实很强大很好用。</p>
<p>而鉴于目前网上一些中文Retrofit的指南我个人认为都不是很详尽（大多只是将官方文档用中文翻译了一下），即便是Retrofit官方指南也没有把大家可能常用到的API解释详尽。</p>
<p>所以本文意在给大家更加详细的讲解如何简单的使用Retrofit。鉴于本人技术有限，对Retrofit的实现原理以及源码等分析做的并不透彻，只是向大家简要介绍Retrofit的使用，使得像我一样的新手能够快速的上手入门。也希望大家向我提出宝贵的意见。</p>
<hr>
<p>有关更多API文档的查阅请大家到<a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit官网</a>查看。</p>
<p>首先咱先把Retrofit集成到项目中来:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.squareup.retrofit:retrofit:1.9.0'</span></span><br></pre></td></tr></table></figure></p>
<p>以下，我将以我们的产品“<a href="http://sj.qq.com/myapp/detail.htm?apkName=com.cxtimes.zhixue" target="_blank" rel="external">知学</a>”中所用到的一些网络请求来为大家阐述Retrofit的简单使用。</p>
<p>对Retrofit而言，有两个类是非常关键的，那就是RestAdapter和我们自定义的接口（在知学中叫做ZhixueApi），前者的的作用有很多，但我们我们必然会用到的就是<strong>指定我们请求网络的主域名</strong>。而后者则负责封装我们在项目中要用到的每一个接口。</p>
<p>首先我们来简单了解下关于ZhixueApi的定义。在这个类中，我会介绍我们用到的几种提交方式以及参数的拼装形式。</p>
<p>另外，在我们的应用中并没有用到GET提交方式，有关的信息在官方指南中也阐述的比较清晰，本文便不在单独讨论GET提交方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ZhixueApi</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1. 无参数post请求, 这里的Coupon则是用来解析服务器返回Json字符串的javabean类, Retrofit默认使用Gson解析</span></span><br><span class="line">	<span class="annotation">@POST</span>(<span class="string">"/interface/xxxxxx"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getCouponList</span><span class="params">(Callback&lt;Coupon&gt; reponse)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2. 一个或几个参数的post请求</span></span><br><span class="line">	<span class="comment">// 注: 如果使用官方指南中提到的@Query和@QueryMap对参数进行封装, 那么默认会将参数拼到URL之中</span></span><br><span class="line">	<span class="comment">// 首先并不建议将参数拼如URL, 其次由于编码原因, 如果选择采用@Query或者@QueryMap类型的注解, 则参数中必然不能有中文</span></span><br><span class="line">	<span class="comment">// 其次如果使用@Query或者@QueryMap, 也就不能使用@FormUrlEncoded注解, 否则参数会消失</span></span><br><span class="line">	<span class="comment">// 如果使用了@FormUrlEncoded注解, 则必须使用@Field或者@FieldMap注解来作为参数</span></span><br><span class="line">	<span class="annotation">@FormUrlEncoded</span></span><br><span class="line">   	<span class="annotation">@POST</span>(<span class="string">"/interface/xxxxxx"</span>)</span><br><span class="line">   	<span class="function"><span class="keyword">void</span> <span class="title">getCourseList</span><span class="params">(@Field(<span class="string">"userId"</span>)</span> String userId, @<span class="title">Field</span><span class="params">(<span class="string">"orderId"</span>)</span> String orderId, Callback&lt;Coupon&gt; response)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3. 通过@FieldMap注解来封装参数</span></span><br><span class="line">	<span class="comment">//注: 如果你的参数只有一个或者两三个, 那么用@Field就基本足够了, 但如果你的参数非常之多, 七八个甚至十几个</span></span><br><span class="line">	<span class="comment">//那么我们就可以用一个Map去封装, 通过key-value的形式封装好Map对象后再传入, 代码会相对整洁, 在做参数传递的时候也不至于乱套</span></span><br><span class="line">	<span class="annotation">@FormUrlEncoded</span></span><br><span class="line">	<span class="annotation">@POST</span>(<span class="string">"/interface/xxxxxx"</span>)</span><br><span class="line">   	<span class="function"><span class="keyword">void</span> <span class="title">getCourseList</span><span class="params">(@FieldMap Map&lt;String,String&gt; paramsMap, Callback&lt;Coupon&gt; response)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4. 提交multipart请求</span></span><br><span class="line">	<span class="comment">// 注: 如果我们要提交用户拍的的照片, 或者是录好的语音, 那么我们就要用到@Multipart这个注解了</span></span><br><span class="line">	<span class="comment">// 在使用Multipart的时候, 注意参数的注解必须是@Part或者@PartMap </span></span><br><span class="line">	<span class="comment">// @PartMap和上面的@FieldMap类似, 都是通过Map封装好参数, 就不过多解释了.</span></span><br><span class="line">	<span class="annotation">@Multipart</span></span><br><span class="line">   	<span class="annotation">@POST</span>(<span class="string">"/interface/photoUpload_servlet"</span>)</span><br><span class="line">   	<span class="function"><span class="keyword">void</span> <span class="title">submitUserPhoto</span><span class="params">(@Part(<span class="string">"userId"</span>)</span> String userId, @<span class="title">Part</span><span class="params">(<span class="string">"file"</span>)</span> TypedFile file, Callback&lt;Coupon&gt; response response)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于上传文件, 我们需要将我们所需上传的File文件转换成TypedFile形式, 在Retrofit中也很简单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先定义一个mimeType类型, 如果我要上传的是一张图片, 就按如下定义</span></span><br><span class="line">String mimeType = <span class="string">"image/jpg"</span>;</span><br><span class="line"><span class="comment">//String mimeType = "audio/m4a";//如果是m4a的声音文件, 就这么定义</span></span><br><span class="line">TypedFile typedFile = <span class="keyword">new</span> TypedFile(mimeType, file);<span class="comment">//调用这个方法将文件转为TypedFile形势, 传参上传即可</span></span><br></pre></td></tr></table></figure></p>
<p>以下这个类是我封装的ZhixueApiUtil，作用是在每次请求接口的时候能够快速的拿到ZhixueApi的实例，所以我在此设计了一个简单的单例模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhixueApiUtil</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ZhixueApiUtil mInstance;</span><br><span class="line">	<span class="comment">//此前定义的接口的实例</span></span><br><span class="line">	<span class="keyword">private</span> ZhixueApi zhixueApi;</span><br><span class="line">	<span class="comment">//我们的主域名</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"http://111.111.111.111"</span>;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">ZhixueApiUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//在构造函数中我们要通过实例化RestAdapter拿到我们的ZhixueApi</span></span><br><span class="line">		<span class="comment">//注: setRequestInterceptor()在这里是为了在请求头中加入设备信息, 方便我们后台的调试</span></span><br><span class="line">		RestAdapter restAdapter = <span class="keyword">new</span> RestAdapter.Builder().setRequestInterceptor(defaultInterceptor).setEndpoint(HOST).build();</span><br><span class="line">		zhixueApi = restAdapter.create(ZhixueApi.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//一个简单的单例</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZhixueApiUtil <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			mInstance = <span class="keyword">new</span> ZhixueApiUtil();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> mInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ZhixueApi <span class="title">getZhixueApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> zhixueApi;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在这里我们还定义了一个RequestInterceptor, 作用是在请求头中拼入一些信息方便我们后台的调试</span></span><br><span class="line">	<span class="comment">//否则请求头中就只会出现okhttp 2.2.0的字样(Retrofit默认是直接使用OkhttpClient的)</span></span><br><span class="line">	RequestInterceptor defaultInterceptor = <span class="keyword">new</span> RequestInterceptor() &#123;</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">intercept</span><span class="params">(RequestFacade request)</span> </span>&#123;</span><br><span class="line">			request.addHeader(<span class="string">"User-Agent"</span>, <span class="string">"some code here"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而当我们手握这两个类的时候, 请求接口就会变得异常的简单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"></span><br><span class="line">ZhixueApiUtil.getInstance().getZhixueApi().getCourseList(paramsMap, <span class="keyword">new</span> Callback&lt;Coupon&gt;()&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(Coupon coupn, Response response)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//在这里Json已经通过Retrofit中含有的Gson包为我们解析好了, 直接拿出来用就好了!</span></span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(RetrofitError error)</span> </span>&#123;</span><br><span class="line">		Log.d(TAG, error.getMessage());</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="到这里，相信大家已经能够基本使用Retrofit了，本人代码经验尚浅，文中有什么不足希望大家多提宝贵意见。">到这里，相信大家已经能够基本使用Retrofit了，本人代码经验尚浅，文中有什么不足希望大家多提宝贵意见。</h3><p>后面我会分享一些Retrofit配合Okhttp配合Stetho配合Chrome做网络调试的经验，以及Retrofit请求网络的速度对比分析。依然都会是一些入门的东西，意在让大家快速的用起来，而更深层次的东西，还需要大家自己多学习，多探讨。</p>
<p>最后的最后，也欢迎大家关注我们正在做的事儿：<a href="http://sj.qq.com/myapp/detail.htm?apkName=com.cxtimes.zhixue" target="_blank" rel="external">知学，一个大学生家教O2O平台</a>，当然这个App在制作上仍然有很多的不足，有希望大家多提宝贵意见。</p>
</div><nav class="pagination"><a id="left-navigator" href="/blog/Android-How-to-get-response-JSON-in-Retrofit/">如何使用Retrofit获取服务器返回来的JSON字符串</a></nav></div><nav id="footer"><ul id="footer-links"><li><a href="/about">About</a></li><li><a href="/archives">Archives</a></li><li><a href="/atom.xml">RSS</a></li><li><a href="https://icylogic.net" class="out-site">Theme.Carbon</a></li><li><a href="https://github.com/hexojs/hexo" class="out-site">Hexo</a></li></ul></nav></div></body></html>